<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Sentence Gen 2</title>
<script src="jquery.js" type="text/javascript"></script>
<script type="text/javascript" src="database.js"></script>
<script type="text/javascript" src="constructions.js"></script>
<script type="text/javascript">

function start(){
	C = new branch(copula)
	
	$(document).ready(function(e) {
		$("body").html(stringOut(C))
		console.log(C.head.head.head.aspect)
		console.log(C.head.head.head.tense)
		console.log(C.head.head.head.number)
		console.log(C.head.head.head.person)
	})
}


function branch(c, r, p, l){
	this.parent = p || null
	this.label = l || null
	
	this.parseRestrictions = parseRestrictions
	
	var r = this.parseRestrictions(r)
	var c = c(r)
	
	//evaluate head first
	if(c.hasOwnProperty("head")){
		this.order = c.order
		this.children = {}
		this.head = this.children[c.head] = new branch(c.children[c.head][0], $.extend(1, r, c.children[c.head][1]), this, c.head)
	}
	
	//evaluate rest of children
	if(c.hasOwnProperty("children")){
		for(var child in c.children){		
			if(this.children[child] != this.head){
				this.children[child] = new branch(c.children[child][0], c.children[child][1], this, child) 
			}
		}
	}
	
	//if this is a leaf node, dump it's guts into this
	if(!c.hasOwnProperty("children")) {
		for(prop in c){
			this[prop] = c[prop];	
		}
		//for words
		if(!c.hasOwnProperty("text")) this.text = c.inflected || c.name
	}
	
	function parseRestrictions(restrictions){
		if (typeof restrictions==='undefined' || isEmpty(restrictions)) return
		
		if (typeof restrictions==='string') {
			try {return eval(restrictions)} 
			catch(e){return this.parseRestrictions("this.parent.children."+restrictions) }
		}
		
		for(var r in restrictions){
			if(restrictions[r].match(/\./)) {
				try {	restrictions[r] = eval(restrictions[r]) }
				catch(e) { restrictions[r] = eval("this.parent.children."+restrictions[r]) }
			}
		}
		return restrictions
	}

}

//picks a specific inflection of/for a word if it has anything special
//returns false if regular inflection can be used
function inflect(word, r){
		if(!word.hasOwnProperty("inflections")) return
	
		r = r || {}
		var query = []
		
		for(var cat in paradigms[word.type]){
				//if a category has already been specified use it
				if(r.hasOwnProperty(cat)) word[cat] = r[cat]
				//otherwise pick one at random
				else word[cat] = pickOne(paradigms[word.type][cat])
				
				query.push(word[cat])
		}
	
		query = query.join("|")
		var regex = "(^|,) *("+query+"|\\.)*("+query+ ")+ *:[^,]*"
		var outcome = word.inflections.match( new RegExp(regex, "gi"))
		
		if(outcome!=null){
			
			word.inflected = outcome.sort(function(a,b){
					return a.split(".").length>b.split(".").length
			})
			.pop().split(":").pop().trim()
			
			return true
						
		} else { 
			word.inflected = ""
			return false 
		}
}

//selects a word from the database that matches the given restrictions
function get(r){
	var word = $.extend({'type': r.type}, pickOne(database[r.type], r))
	
	inflect(word,r)
	
	return word
}

//utility function for randomly picking one element from an array
function pickOne(arr, r){
	var r = r || null;
	if(!isEmpty(r)){
		var slim = $.grep(arr, slimmer)
		return slim[Math.floor(Math.random()*slim.length)]
	}
	//just pick one at random
	else return arr[Math.floor(Math.random()*arr.length)]	
	
	function slimmer(a){
		return r_match(r,a)	
	}
}

function stringOut(c){
	if(c.children){
		
		var c = c
	
		var string = c.order.replace(/([^_ ])+/g, function(a){
			return stringOut(c.children[a])
		})
		return string.replace("_", "")
	}
	else return c.text
	
	
}

/******************* Construction Instructions *******************/

function route(r, choices){
	return choices[r] || choices["rest"] || ""
}

/****************************************************************/

//tests an object against a restrictions template
//if they have the same properties they must match, otherwise, who cares
function r_match(restrictions, test_object){
	if (isEmpty(restrictions)) return true
	
	for(var r in restrictions){
			if (test_object.hasOwnProperty(r)){
				if(test_object[r] == restrictions[r]) continue
				else return false
			} else continue
	}
	return true
}

//utility to check for empty object
function isEmpty(o) {
		for (var p in o) { if (o.hasOwnProperty(p)) return false; }
		return true;
}
	
	
start()	
</script>
</head>

<body>
</body>
</html>